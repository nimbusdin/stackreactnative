{"ast":null,"code":"'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _jsxFileName = \"/Users/nicastelo/Lab/react-native-swipeable-lists/src/SwipeableRow.js\";\nvar IS_RTL = _reactNative.I18nManager.isRTL;\nvar CLOSED_LEFT_POSITION = 0;\nvar HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;\nvar HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;\nvar SLOW_SPEED_SWIPE_FACTOR = 4;\nvar SWIPE_DURATION = 300;\nvar ON_MOUNT_BOUNCE_DELAY = 700;\nvar ON_MOUNT_BOUNCE_DURATION = 400;\nvar RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;\nvar RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;\nvar RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;\nvar DEFAULT_SWIPE_THRESHOLD = 30;\n\nvar emptyFunction = function emptyFunction() {};\n\nvar SwipeableRow = function (_React$Component) {\n  (0, _inherits2.default)(SwipeableRow, _React$Component);\n\n  function SwipeableRow() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    (0, _classCallCheck2.default)(this, SwipeableRow);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(SwipeableRow)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _this._handleMoveShouldSetPanResponderCapture = function (event, gestureState) {\n      return gestureState.dy < 10 && _this._isValidSwipe(gestureState);\n    };\n\n    _this._handlePanResponderGrant = function (event, gestureState) {};\n\n    _this._handlePanResponderMove = function (event, gestureState) {\n      if (_this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {\n        return;\n      }\n\n      _this.props.onSwipeStart && _this.props.onSwipeStart();\n\n      if (_this._isSwipingRightFromClosed(gestureState)) {\n        _this._swipeSlowSpeed(gestureState);\n      } else {\n        _this._swipeFullSpeed(gestureState);\n      }\n    };\n\n    _this._onPanResponderTerminationRequest = function (event, gestureState) {\n      return false;\n    };\n\n    _this._handlePanResponderEnd = function (event, gestureState) {\n      var horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;\n\n      if (_this._isSwipingRightFromClosed(gestureState)) {\n        _this.props.onOpen && _this.props.onOpen();\n\n        _this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n      } else if (_this._shouldAnimateRemainder(gestureState)) {\n        if (horizontalDistance < 0) {\n          _this.props.onOpen && _this.props.onOpen();\n\n          _this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);\n        } else {\n          _this.props.onClose && _this.props.onClose();\n\n          _this._animateToClosedPosition();\n        }\n      } else {\n        if (_this._previousLeft === CLOSED_LEFT_POSITION) {\n          _this._animateToClosedPosition();\n        } else {\n          _this._animateToOpenPosition();\n        }\n      }\n\n      _this.props.onSwipeEnd && _this.props.onSwipeEnd();\n    };\n\n    _this._panResponder = _reactNative.PanResponder.create({\n      onMoveShouldSetPanResponderCapture: _this._handleMoveShouldSetPanResponderCapture,\n      onPanResponderGrant: _this._handlePanResponderGrant,\n      onPanResponderMove: _this._handlePanResponderMove,\n      onPanResponderRelease: _this._handlePanResponderEnd,\n      onPanResponderTerminationRequest: _this._onPanResponderTerminationRequest,\n      onPanResponderTerminate: _this._handlePanResponderEnd,\n      onShouldBlockNativeResponder: function onShouldBlockNativeResponder(event, gestureState) {\n        return false;\n      }\n    });\n    _this._previousLeft = CLOSED_LEFT_POSITION;\n    _this._timeoutID = null;\n    _this.state = {\n      currentLeft: new _reactNative.Animated.Value(_this._previousLeft),\n      isSwipeableViewRendered: false,\n      rowHeight: null\n    };\n\n    _this._onSwipeableViewLayout = function (event) {\n      _this.setState({\n        isSwipeableViewRendered: true,\n        rowHeight: event.nativeEvent.layout.height\n      });\n    };\n\n    _this._animateToClosedPositionDuringBounce = function () {\n      _this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n    };\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(SwipeableRow, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (this.props.shouldBounceOnMount) {\n        this._timeoutID = setTimeout(function () {\n          _this2._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);\n        }, ON_MOUNT_BOUNCE_DELAY);\n      }\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var _this$props$isOpen, _nextProps$isOpen;\n\n      var isOpen = (_this$props$isOpen = this.props.isOpen) != null ? _this$props$isOpen : false;\n      var nextIsOpen = (_nextProps$isOpen = nextProps.isOpen) != null ? _nextProps$isOpen : false;\n\n      if (isOpen && !nextIsOpen) {\n        this._animateToClosedPosition();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._timeoutID != null) {\n        clearTimeout(this._timeoutID);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var slideOutView;\n\n      if (this.state.isSwipeableViewRendered && this.state.rowHeight) {\n        slideOutView = _react.default.createElement(_reactNative.View, {\n          style: [styles.slideOutContainer, {\n            height: this.state.rowHeight\n          }],\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 221\n          }\n        }, this.props.slideoutView);\n      }\n\n      var swipeableView = _react.default.createElement(_reactNative.Animated.View, {\n        onLayout: this._onSwipeableViewLayout,\n        style: {\n          transform: [{\n            translateX: this.state.currentLeft\n          }]\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 230\n        }\n      }, this.props.children);\n\n      return _react.default.createElement(_reactNative.View, (0, _extends2.default)({}, this._panResponder.panHandlers, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 238\n        }\n      }), slideOutView, swipeableView);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.props.onClose && this.props.onClose();\n\n      this._animateToClosedPosition();\n    }\n  }, {\n    key: \"_isSwipingRightFromClosed\",\n    value: function _isSwipingRightFromClosed(gestureState) {\n      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n      return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;\n    }\n  }, {\n    key: \"_swipeFullSpeed\",\n    value: function _swipeFullSpeed(gestureState) {\n      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);\n    }\n  }, {\n    key: \"_swipeSlowSpeed\",\n    value: function _swipeSlowSpeed(gestureState) {\n      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR);\n    }\n  }, {\n    key: \"_isSwipingExcessivelyRightFromClosedPosition\",\n    value: function _isSwipingExcessivelyRightFromClosedPosition(gestureState) {\n      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n      return this._isSwipingRightFromClosed(gestureState) && gestureStateDx > RIGHT_SWIPE_THRESHOLD;\n    }\n  }, {\n    key: \"_animateTo\",\n    value: function _animateTo(toValue) {\n      var _this3 = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SWIPE_DURATION;\n      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : emptyFunction;\n\n      _reactNative.Animated.timing(this.state.currentLeft, {\n        duration: duration,\n        toValue: toValue,\n        useNativeDriver: true\n      }).start(function () {\n        _this3._previousLeft = toValue;\n        callback();\n      });\n    }\n  }, {\n    key: \"_animateToOpenPosition\",\n    value: function _animateToOpenPosition() {\n      var _this$props$maxSwipeD;\n\n      var maxSwipeDistance = (_this$props$maxSwipeD = this.props.maxSwipeDistance) != null ? _this$props$maxSwipeD : 0;\n      var directionAwareMaxSwipeDistance = IS_RTL ? -maxSwipeDistance : maxSwipeDistance;\n\n      this._animateTo(-directionAwareMaxSwipeDistance);\n    }\n  }, {\n    key: \"_animateToOpenPositionWith\",\n    value: function _animateToOpenPositionWith(speed, distMoved) {\n      var _this$props$maxSwipeD2;\n\n      speed = speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD ? speed : HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;\n      var maxSwipeDistance = (_this$props$maxSwipeD2 = this.props.maxSwipeDistance) != null ? _this$props$maxSwipeD2 : 0;\n      var duration = Math.abs((maxSwipeDistance - Math.abs(distMoved)) / speed);\n      var directionAwareMaxSwipeDistance = IS_RTL ? -maxSwipeDistance : maxSwipeDistance;\n\n      this._animateTo(-directionAwareMaxSwipeDistance, duration);\n    }\n  }, {\n    key: \"_animateToClosedPosition\",\n    value: function _animateToClosedPosition() {\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SWIPE_DURATION;\n\n      this._animateTo(CLOSED_LEFT_POSITION, duration);\n    }\n  }, {\n    key: \"_animateBounceBack\",\n    value: function _animateBounceBack(duration) {\n      var swipeBounceBackDistance = IS_RTL ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;\n\n      this._animateTo(-swipeBounceBackDistance, duration, this._animateToClosedPositionDuringBounce);\n    }\n  }, {\n    key: \"_isValidSwipe\",\n    value: function _isValidSwipe(gestureState) {\n      var _this$props$preventSw;\n\n      var preventSwipeRight = (_this$props$preventSw = this.props.preventSwipeRight) != null ? _this$props$preventSw : false;\n\n      if (preventSwipeRight && this._previousLeft === CLOSED_LEFT_POSITION && gestureState.dx > 0) {\n        return false;\n      }\n\n      return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;\n    }\n  }, {\n    key: \"_shouldAnimateRemainder\",\n    value: function _shouldAnimateRemainder(gestureState) {\n      var _this$props$swipeThre;\n\n      var swipeThreshold = (_this$props$swipeThre = this.props.swipeThreshold) != null ? _this$props$swipeThre : DEFAULT_SWIPE_THRESHOLD;\n      return Math.abs(gestureState.dx) > swipeThreshold || gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;\n    }\n  }]);\n  return SwipeableRow;\n}(_react.default.Component);\n\nvar styles = _reactNative.StyleSheet.create({\n  slideOutContainer: {\n    bottom: 0,\n    left: 0,\n    position: 'absolute',\n    right: 0,\n    top: 0\n  }\n});\n\nvar _default = SwipeableRow;\nexports.default = _default;","map":{"version":3,"sources":["SwipeableRow.js"],"names":["IS_RTL","I18nManager","CLOSED_LEFT_POSITION","HORIZONTAL_SWIPE_DISTANCE_THRESHOLD","HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD","SLOW_SPEED_SWIPE_FACTOR","SWIPE_DURATION","ON_MOUNT_BOUNCE_DELAY","ON_MOUNT_BOUNCE_DURATION","RIGHT_SWIPE_BOUNCE_BACK_DISTANCE","RIGHT_SWIPE_BOUNCE_BACK_DURATION","RIGHT_SWIPE_THRESHOLD","DEFAULT_SWIPE_THRESHOLD","emptyFunction","SwipeableRow","React","Component","_handleMoveShouldSetPanResponderCapture","gestureState","_handlePanResponderGrant","_handlePanResponderMove","_onPanResponderTerminationRequest","_handlePanResponderEnd","horizontalDistance","_panResponder","PanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderRelease","onPanResponderTerminationRequest","onPanResponderTerminate","onShouldBlockNativeResponder","_previousLeft","_timeoutID","state","currentLeft","Animated","isSwipeableViewRendered","rowHeight","setTimeout","nextProps","isOpen","nextIsOpen","clearTimeout","slideOutView","styles","height","swipeableView","transform","translateX","_onSwipeableViewLayout","event","gestureStateDx","toValue","duration","callback","useNativeDriver","maxSwipeDistance","directionAwareMaxSwipeDistance","speed","distMoved","Math","_animateToClosedPositionDuringBounce","swipeBounceBackDistance","preventSwipeRight","swipeThreshold","StyleSheet","slideOutContainer","bottom","left","position","right","top"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport React from 'react';\n\nimport {\n  Animated,\n  I18nManager,\n  PanResponder,\n  StyleSheet,\n  View,\n} from 'react-native';\n\nimport type {\n  LayoutEvent,\n  PressEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport type {GestureState} from 'react-native/Libraries/Interaction/PanResponder';\n\nconst IS_RTL = I18nManager.isRTL;\n\n// NOTE: Eventually convert these consts to an input object of configurations\n\n// Position of the left of the swipable item when closed\nconst CLOSED_LEFT_POSITION = 0;\n// Minimum swipe distance before we recognize it as such\nconst HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;\n// Minimum swipe speed before we fully animate the user's action (open/close)\nconst HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;\n// Factor to divide by to get slow speed; i.e. 4 means 1/4 of full speed\nconst SLOW_SPEED_SWIPE_FACTOR = 4;\n// Time, in milliseconds, of how long the animated swipe should be\nconst SWIPE_DURATION = 300;\n\n/**\n * On SwipeableListView mount, the 1st item will bounce to show users it's\n * possible to swipe\n */\nconst ON_MOUNT_BOUNCE_DELAY = 700;\nconst ON_MOUNT_BOUNCE_DURATION = 400;\n\n// Distance left of closed position to bounce back when right-swiping from closed\nconst RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;\nconst RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;\n/**\n * Max distance of right swipe to allow (right swipes do functionally nothing).\n * Must be multiplied by SLOW_SPEED_SWIPE_FACTOR because gestureState.dx tracks\n * how far the finger swipes, and not the actual animation distance.\n */\nconst RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;\nconst DEFAULT_SWIPE_THRESHOLD = 30;\n\nconst emptyFunction = () => {};\n\ntype Props = $ReadOnly<{|\n  children?: ?React.Node,\n  isOpen?: ?boolean,\n  maxSwipeDistance?: ?number,\n  onClose?: ?() => void,\n  onOpen?: ?() => void,\n  onSwipeEnd?: ?() => void,\n  onSwipeStart?: ?() => void,\n  preventSwipeRight?: ?boolean,\n  shouldBounceOnMount?: ?boolean,\n  slideoutView?: ?React.Node,\n  swipeThreshold?: ?number,\n|}>;\n\ntype State = {\n  currentLeft: Animated.Value,\n  isSwipeableViewRendered: boolean,\n  rowHeight: ?number,\n};\n\n/**\n * Creates a swipable row that allows taps on the main item and a custom View\n * on the item hidden behind the row. Typically this should be used in\n * conjunction with SwipeableListView for additional functionality, but can be\n * used in a normal ListView. See the renderRow for SwipeableListView to see how\n * to use this component separately.\n */\nclass SwipeableRow extends React.Component<Props, State> {\n  _handleMoveShouldSetPanResponderCapture = (\n    event: PressEvent,\n    gestureState: GestureState,\n  ): boolean => {\n    // Decides whether a swipe is responded to by this component or its child\n    return gestureState.dy < 10 && this._isValidSwipe(gestureState);\n  };\n\n  _handlePanResponderGrant = (\n    event: PressEvent,\n    gestureState: GestureState,\n  ): void => {};\n\n  _handlePanResponderMove = (\n    event: PressEvent,\n    gestureState: GestureState,\n  ): void => {\n    if (this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {\n      return;\n    }\n\n    this.props.onSwipeStart && this.props.onSwipeStart();\n\n    if (this._isSwipingRightFromClosed(gestureState)) {\n      this._swipeSlowSpeed(gestureState);\n    } else {\n      this._swipeFullSpeed(gestureState);\n    }\n  };\n\n  _onPanResponderTerminationRequest = (\n    event: PressEvent,\n    gestureState: GestureState,\n  ): boolean => {\n    return false;\n  };\n\n  _handlePanResponderEnd = (\n    event: PressEvent,\n    gestureState: GestureState,\n  ): void => {\n    const horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;\n    if (this._isSwipingRightFromClosed(gestureState)) {\n      this.props.onOpen && this.props.onOpen();\n      this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n    } else if (this._shouldAnimateRemainder(gestureState)) {\n      if (horizontalDistance < 0) {\n        // Swiped left\n        this.props.onOpen && this.props.onOpen();\n        this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);\n      } else {\n        // Swiped right\n        this.props.onClose && this.props.onClose();\n        this._animateToClosedPosition();\n      }\n    } else {\n      if (this._previousLeft === CLOSED_LEFT_POSITION) {\n        this._animateToClosedPosition();\n      } else {\n        this._animateToOpenPosition();\n      }\n    }\n\n    this.props.onSwipeEnd && this.props.onSwipeEnd();\n  };\n\n  _panResponder = PanResponder.create({\n    onMoveShouldSetPanResponderCapture: this\n      ._handleMoveShouldSetPanResponderCapture,\n    onPanResponderGrant: this._handlePanResponderGrant,\n    onPanResponderMove: this._handlePanResponderMove,\n    onPanResponderRelease: this._handlePanResponderEnd,\n    onPanResponderTerminationRequest: this._onPanResponderTerminationRequest,\n    onPanResponderTerminate: this._handlePanResponderEnd,\n    onShouldBlockNativeResponder: (event, gestureState) => false,\n  });\n\n  _previousLeft = CLOSED_LEFT_POSITION;\n  _timeoutID: ?TimeoutID = null;\n\n  state = {\n    currentLeft: new Animated.Value(this._previousLeft),\n    /**\n     * In order to render component A beneath component B, A must be rendered\n     * before B. However, this will cause \"flickering\", aka we see A briefly\n     * then B. To counter this, _isSwipeableViewRendered flag is used to set\n     * component A to be transparent until component B is loaded.\n     */\n    isSwipeableViewRendered: false,\n    rowHeight: null,\n  };\n\n  componentDidMount(): void {\n    if (this.props.shouldBounceOnMount) {\n      /**\n       * Do the on mount bounce after a delay because if we animate when other\n       * components are loading, the animation will be laggy\n       */\n      this._timeoutID = setTimeout(() => {\n        this._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);\n      }, ON_MOUNT_BOUNCE_DELAY);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: $Shape<Props>): void {\n    /**\n     * We do not need an \"animateOpen(noCallback)\" because this animation is\n     * handled internally by this component.\n     */\n    const isOpen = this.props.isOpen ?? false;\n    const nextIsOpen = nextProps.isOpen ?? false;\n\n    if (isOpen && !nextIsOpen) {\n      this._animateToClosedPosition();\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._timeoutID != null) {\n      clearTimeout(this._timeoutID);\n    }\n  }\n\n  render(): React.Element<any> {\n    // The view hidden behind the main view\n    let slideOutView;\n    if (this.state.isSwipeableViewRendered && this.state.rowHeight) {\n      slideOutView = (\n        <View\n          style={[styles.slideOutContainer, {height: this.state.rowHeight}]}>\n          {this.props.slideoutView}\n        </View>\n      );\n    }\n\n    // The swipeable item\n    const swipeableView = (\n      <Animated.View\n        onLayout={this._onSwipeableViewLayout}\n        style={{transform: [{translateX: this.state.currentLeft}]}}>\n        {this.props.children}\n      </Animated.View>\n    );\n\n    return (\n      <View {...this._panResponder.panHandlers}>\n        {slideOutView}\n        {swipeableView}\n      </View>\n    );\n  }\n\n  close(): void {\n    this.props.onClose && this.props.onClose();\n    this._animateToClosedPosition();\n  }\n\n  _onSwipeableViewLayout = (event: LayoutEvent): void => {\n    this.setState({\n      isSwipeableViewRendered: true,\n      rowHeight: event.nativeEvent.layout.height,\n    });\n  };\n\n  _isSwipingRightFromClosed(gestureState: GestureState): boolean {\n    const gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n    return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;\n  }\n\n  _swipeFullSpeed(gestureState: GestureState): void {\n    this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);\n  }\n\n  _swipeSlowSpeed(gestureState: GestureState): void {\n    this.state.currentLeft.setValue(\n      this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR,\n    );\n  }\n\n  _isSwipingExcessivelyRightFromClosedPosition(\n    gestureState: GestureState,\n  ): boolean {\n    /**\n     * We want to allow a BIT of right swipe, to allow users to know that\n     * swiping is available, but swiping right does not do anything\n     * functionally.\n     */\n    const gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n    return (\n      this._isSwipingRightFromClosed(gestureState) &&\n      gestureStateDx > RIGHT_SWIPE_THRESHOLD\n    );\n  }\n\n  _animateTo(\n    toValue: number,\n    duration: number = SWIPE_DURATION,\n    callback: Function = emptyFunction,\n  ): void {\n    Animated.timing(this.state.currentLeft, {\n      duration,\n      toValue,\n      useNativeDriver: true,\n    }).start(() => {\n      this._previousLeft = toValue;\n      callback();\n    });\n  }\n\n  _animateToOpenPosition(): void {\n    const maxSwipeDistance = this.props.maxSwipeDistance ?? 0;\n    const directionAwareMaxSwipeDistance = IS_RTL\n      ? -maxSwipeDistance\n      : maxSwipeDistance;\n    this._animateTo(-directionAwareMaxSwipeDistance);\n  }\n\n  _animateToOpenPositionWith(speed: number, distMoved: number): void {\n    /**\n     * Ensure the speed is at least the set speed threshold to prevent a slow\n     * swiping animation\n     */\n    speed =\n      speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD\n        ? speed\n        : HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;\n    const maxSwipeDistance = this.props.maxSwipeDistance ?? 0;\n    /**\n     * Calculate the duration the row should take to swipe the remaining distance\n     * at the same speed the user swiped (or the speed threshold)\n     */\n    const duration = Math.abs((maxSwipeDistance - Math.abs(distMoved)) / speed);\n    const directionAwareMaxSwipeDistance = IS_RTL\n      ? -maxSwipeDistance\n      : maxSwipeDistance;\n    this._animateTo(-directionAwareMaxSwipeDistance, duration);\n  }\n\n  _animateToClosedPosition(duration: number = SWIPE_DURATION): void {\n    this._animateTo(CLOSED_LEFT_POSITION, duration);\n  }\n\n  _animateToClosedPositionDuringBounce = (): void => {\n    this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n  };\n\n  _animateBounceBack(duration: number): void {\n    /**\n     * When swiping right, we want to bounce back past closed position on release\n     * so users know they should swipe right to get content.\n     */\n    const swipeBounceBackDistance = IS_RTL\n      ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE\n      : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;\n    this._animateTo(\n      -swipeBounceBackDistance,\n      duration,\n      this._animateToClosedPositionDuringBounce,\n    );\n  }\n\n  // Ignore swipes due to user's finger moving slightly when tapping\n  _isValidSwipe(gestureState: GestureState): boolean {\n    const preventSwipeRight = this.props.preventSwipeRight ?? false;\n    if (\n      preventSwipeRight &&\n      this._previousLeft === CLOSED_LEFT_POSITION &&\n      gestureState.dx > 0\n    ) {\n      return false;\n    }\n\n    return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;\n  }\n\n  _shouldAnimateRemainder(gestureState: GestureState): boolean {\n    /**\n     * If user has swiped past a certain distance, animate the rest of the way\n     * if they let go\n     */\n    const swipeThreshold = this.props.swipeThreshold ?? DEFAULT_SWIPE_THRESHOLD;\n    return (\n      Math.abs(gestureState.dx) > swipeThreshold ||\n      gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  slideOutContainer: {\n    bottom: 0,\n    left: 0,\n    position: 'absolute',\n    right: 0,\n    top: 0,\n  },\n});\n\nexport default SwipeableRow;\n"]},"metadata":{},"sourceType":"script"}